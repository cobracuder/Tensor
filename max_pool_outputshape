#include <bits/stdc++.h>
using namespace std;
#define DEBUG_OPTION 1
#define ALLIGNDOWN(a, b) ((a / b) * b)

namespace cobra{
/*----------- mdspan struct ---------*/
template<typename T>
struct mdspan {
    T *data;
    vector<int> shape;
};

/*------- To initialize data ------*/
template<typename T>
void initialize(vector<T>& data) {
    int size = data.size();
    for (int i = 0; i < size; i++) {
        data[i] = i + 1;
    }
} // initialize

/*------- To Calc Stride -------*/
template<typename T>
auto cal_stride(const vector<T>& shape) {
    vector<T> stride(shape.size(), 1);
    for (int64_t i = shape.size() - 2; i >= 0; --i) {
        stride[i] = stride[i + 1] * shape[i + 1];
    }
    return stride;
} // cal_stride

/*-------- print function ---------*/
template<typename T>
void print(const vector<T>& arr) {
    if (DEBUG_OPTION) {
        std::cout << endl;
        for (auto i : arr) {
            std::cout << i << ", ";
        }
        std::cout << endl;
    }
} // print

template<typename T>
void print(const T& s) {
    if (DEBUG_OPTION) {
        std::cout << endl << s << endl;
    }
} // print

// special case print
namespace sp{
template<typename T>
void print(const T *arr) {
    if (DEBUG_OPTION) {
        int size = 2;
        std::cout << endl;
        for (auto i = 0; i <size; i++) {
            std::cout << arr[i] << ", ";
        }
        std::cout << endl;
    }
} // print
}


/*----- To Print Multi-Dimension array ------*/
template<typename T>
void dis(int dim, int idx, T *data, const vector<int>& st, const vector<int>& sh, int rank) {
    if (dim == rank) {
        std::cout << data[idx] << ", ";
        return;
    }

    std::cout << "[ ";
    for (int i = 0; i < sh[dim]; i++) {
        dis(dim + 1, idx + st[dim] * i, data, st, sh, rank);
    }
    std::cout << "]\n";
} // dis

template<typename T>
void print(mdspan<T> *ob, string s = "") {
    if (DEBUG_OPTION) {
        std::cout<<s;
        std::cout << "\nShape: \n";
        for (auto i : ob->shape) {
            std::cout << i << ", ";
        }
        std::cout << "\nDATA: \n";
        dis(0, 0, ob->data, cal_stride(ob->shape), ob->shape, ob->shape.size());
        std::cout << endl;
    }
} // print

/*--------- cpy function ------------*/
template<typename T1, typename T2>
void cpy(int dim, int dst, int src, const vector<T1>& dst_st, const vector<T1>& src_st,
         const vector<T1>& dst_sh, const vector<T1>& src_sh, int rank, T2 *out, T2 *in,
         const vector<int>& src_offset, const vector<int>& dst_offset) {
    if (dim == rank) {
        out[dst] = in[src];
        return;
    }
    for (int i = dst_offset[dim], j = src_offset[dim];
         i < dst_sh[dim] && j < src_sh[dim]; i++, j++) {
        cpy(dim + 1, dst + dst_st[dim] * i, src + src_st[dim] * j,
            dst_st, src_st, dst_sh, src_sh, rank, out, in, src_offset, dst_offset);
    }
} // cpy

/*--------- slice function ----------*/
template<typename T>
void slice(mdspan<T> *des, mdspan<T> *source,
            vector<int> dst_offset = {}, vector<int> src_offset = {}) {
    auto des_st = cal_stride(des->shape);
    auto src_st = cal_stride(source->shape);
    int rank = des_st.size();

    if (dst_offset.empty()) {
        dst_offset.resize(rank, 0);
    }
    if (src_offset.empty()) {
        src_offset.resize(rank, 0);
    }

    cpy(0, 0, 0, des_st, src_st, des->shape, source->shape, rank,
        des->data, source->data, src_offset, dst_offset);
} // slice
} // namespace cobra

/*--------- Max Pool function ----------*/
struct op_para {
    int kernel[3];
    bool ceil_mode;
    int stride[2];
    int dilation[2];
    int dilated_kernel[2];
    int padding[4];
};

template<typename T>
void maxpool_cfunc(T *out, T *in, int w, int h, int c, op_para para) {
    int count = 0;
    for (int j = 0; j < w; j++) {
        for (int k = 0; k < h; k += para.stride[0]) {
            for (int i = 0; i < c; i += para.stride[1]) {
                if (!((k + para.dilated_kernel[0] <= h) && (i + para.dilated_kernel[1] <= c) || para.ceil_mode)) {
                    // cout<<"\n->"<<k<<" "<< para.dilated_kernel[0]<<" "<<h;
                    out[count] = -787788987;
                    continue;
                }

                // cobra::print(vector<int>{j, k, i});
                // cout<<"\ncount"<<count<<'\n';
                int mx = INT_MIN;
                for (int d_l = 0; d_l < para.dilated_kernel[0]; d_l += (para.dilation[0])) {
                    for (int d_m = 0; d_m < para.dilated_kernel[1]; d_m += (para.dilation[1])) {
                        if ((k + d_l < h) && (i + d_m < c)) {
                            mx = max(mx, in[(j * (h * c)) + ((k + d_l) * c) + i + d_m]);
                            if (in[(j * (h * c)) + ((k + d_l) * c) + i + d_m] == 12) {
                                // cout<<"--->"<<k + d_l<<" "<< d_m<<endl;
                            }
                        }
                    }
                }
                // cout<<"->";
                // cout<<mx;
                out[count] = mx;
                count++;
            }
        }
    }
} // maxpool_cfunc

/******************************************************************************************/

int main() {
    vector<int> in_l1_mem(100, 0);
    vector<int> src(125);
    vector<int> out_l1_mem(100, INT_MIN);
    vector<int> dst(125);

    cobra::initialize(src);

    /*------------------ INITIALIZE PARA ----------------*/
    op_para para;
    para.kernel[0] = 2;
    para.kernel[1] = 2;
    para.ceil_mode = 0;
    para.stride[0] = 1;
    para.stride[1] = 1;
    para.dilation[0] = 1;
    para.dilation[1] = 1;
    para.dilated_kernel[0] = para.dilation[0] * (para.kernel[0] - 1) + 1;
    para.dilated_kernel[1] = para.dilation[1] * (para.kernel[1] - 1) + 1;
    para.padding[0] = 0;
    para.padding[1] = 0;
    cobra::sp::print(para.padding);

    /*------------------- shapes -------------------------*/
    vector<int> input_g_shape = {1, 2, 4};
    vector<int> input_l_shape = {1, 3, 6};
    vector<int> output_g_shape = {1, 2, 4};
    vector<int> output_l_shape = {1, 2, 3};

    /*------------------- mdspan setup -------------------*/
    // cobra::mdspan<int> in_l{in_l1_mem.data(), input_l_shape};
    cobra::mdspan<int> in_g{src.data(), input_g_shape};
    cobra::mdspan<int> out_l{out_l1_mem.data(), output_l_shape};
    cobra::mdspan<int> out_g{dst.data(), output_g_shape};

    /**************************************************************/
    int W, H, C;
    W = output_g_shape[0];
    H = output_g_shape[1];// + 2 * para.padding[0];
    C = output_g_shape[2];// + 2 * para.padding[1];

    int w, h, c;
    w = output_l_shape[0];
    h = output_l_shape[1];
    c = output_l_shape[2];

    for (int i = 0; i < W; i += w) {
        for (int j = 0, j_out = 0; j_out < H; j_out += h) {
            for (int k = 0, k_out = 0; k_out < C; k_out += c){
                int in_h_size = w * para.stride[0] + para.dilated_kernel[0];
                int in_c_size = h * para.stride[1] + para.dilated_kernel[1];
                cout<<in_h_size<<"\t"<<in_c_size<<endl;
                cobra::print(vector<int>{i, j * para.stride[0] + para.dilated_kernel[0],
                                            k * para.stride[1] + para.dilated_kernel[1]});
            }
        }
    }
    /**************************************************************/
    return 0;
}
